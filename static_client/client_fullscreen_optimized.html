<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Shooter - Fullscreen Optimized</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
          "imports": {
            "flatbuffers": "https://cdn.jsdelivr.net/npm/flatbuffers@25.2.10/mjs/flatbuffers.js"
          }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0a0a0a;
        }

        /* Fullscreen game container */
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #pixiContainer {
            width: 100%;
            height: 100%;
        }

        #pixiContainer canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* Toggle button for sidebar */
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background-color: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.5);
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .menu-toggle:hover {
            background-color: rgba(55, 65, 81, 0.9);
            transform: scale(1.1);
        }

        /* Sidebar overlay */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: -400px;
            width: 380px;
            height: 100vh;
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(75, 85, 99, 0.3);
            transition: left 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
            padding: 80px 20px 20px 20px;
        }

        .sidebar-overlay.active {
            left: 0;
        }

        /* Close button inside sidebar */
        .sidebar-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 24px;
            transition: color 0.2s;
        }

        .sidebar-close:hover {
            color: #ffffff;
        }

        /* Settings button */
        .settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background-color: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.5);
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .settings-toggle:hover {
            background-color: rgba(55, 65, 81, 0.9);
            transform: scale(1.1);
        }

        /* Semi-transparent panels */
        .panel {
            background-color: rgba(31, 41, 55, 0.7);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
        }

        /* Log styles */
        .log-entry {
            padding: 6px;
            margin-bottom: 2px;
            border-radius: 4px;
            font-size: 0.8rem;
            background-color: rgba(0, 0, 0, 0.3);
        }

        .log-info { color: #60a5fa; }
        .log-success { color: #34d399; }
        .log-error { color: #f87171; }
        .log-send { color: #fbbf24; }
        .log-receive { color: #a78bfa; }

        /* Kill feed - top right */
        .kill-feed {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 280px;
            background-color: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 180px;
            overflow-y: auto;
            z-index: 100;
        }

        .kill-entry {
            color: #E5E7EB;
            font-size: 13px;
            margin-bottom: 5px;
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Chat display - bottom left */
        .chat-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background-color: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 180px;
            overflow-y: auto;
            z-index: 100;
        }

        .chat-entry {
            color: #D1D5DB;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .chat-entry .username {
            font-weight: bold;
        }

        /* Match info - top center */
        .match-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 8px;
            padding: 8px 20px;
            text-align: center;
            color: #E5E7EB;
            z-index: 100;
            font-size: 14px;
        }

        .team-scores {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 5px;
        }

        .team-score {
            font-weight: bold;
        }

        .team-red { color: #FF6B6B; }
        .team-blue { color: #4ECDC4; }
        .team-ffa { color: #60A5FA; }

        /* FPS counter */
        .fps-counter {
            position: fixed;
            top: 80px;
            left: 20px;
            background-color: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            padding: 5px 10px;
            border-radius: 6px;
            color: #D1D5DB;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }

        /* Minimap container */
        #minimapContainer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            border-radius: 6px;
            background-color: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        /* Scoreboard */
        .scoreboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            background-color: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            color: #E5E7EB;
        }

        .scoreboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
        }

        .scoreboard-header h3 {
            font-size: 1.5rem;
            font-weight: bold;
            color: #93C5FD;
        }

        .close-btn {
            cursor: pointer;
            font-size: 1.8rem;
            color: #9CA3AF;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: #F9FAFB;
        }

        /* Settings menu */
        .settings-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background-color: rgba(31, 41, 55, 0.97);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(75, 85, 99, 0.3);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            z-index: 2001;
            color: #E5E7EB;
        }

        .settings-menu h3 {
            font-size: 1.6rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            color: #A5B4FC;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group h4 {
            font-size: 1.1rem;
            color: #D1D5DB;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
        }

        /* Buttons */
        .btn-primary {
            background-color: rgba(99, 102, 241, 0.8);
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .btn-primary:hover {
            background-color: rgba(79, 70, 229, 0.9);
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background-color: rgba(107, 114, 128, 0.6);
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: rgba(75, 85, 99, 0.8);
            color: #D1D5DB;
            padding: 10px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background-color: rgba(107, 114, 128, 0.9);
        }

        /* Input styles */
        input[type="text"], input[type="range"], select {
            background-color: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(75, 85, 99, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.5);
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(45, 55, 72, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(74, 85, 104, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(113, 128, 150, 0.5);
        }

        .hidden {
            display: none !important;
        }

        /* Powerup status indicators */
        .powerup-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            padding: 3px 6px;
            background-color: rgba(55, 65, 81, 0.7);
            border-radius: 4px;
            margin-bottom: 3px;
        }

        .powerup-indicator .icon {
            font-size: 14px;
        }

        /* Team sections for scoreboard */
        .scoreboard-teams {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .scoreboard-teams.two-columns {
            grid-template-columns: 1fr 1fr;
        }

        .team-section h4 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
        }

        .team-section table {
            width: 100%;
            border-collapse: collapse;
        }

        .team-section th,
        .team-section td {
            padding: 6px 8px;
            text-align: left;
            font-size: 0.9rem;
        }

        .team-section th {
            background-color: rgba(55, 65, 81, 0.5);
            color: #D1D5DB;
        }

        .team-section tr:nth-child(even) {
            background-color: rgba(55, 65, 81, 0.2);
        }

        /* Network quality indicator container */
        #networkQualityIndicator {
            position: fixed;
            bottom: 20px;
            left: 380px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .sidebar-overlay.active ~ #networkQualityIndicator {
            left: 380px;
        }

        .sidebar-overlay:not(.active) ~ #networkQualityIndicator {
            left: 20px;
        }
    </style>
</head>

<body>
    <!-- Game Canvas (Fullscreen) -->
    <div id="gameContainer">
        <div id="pixiContainer"></div>
    </div>

    <!-- Menu Toggle Button -->
    <button class="menu-toggle" id="menuToggle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>

    <!-- Settings Toggle Button -->
    <button class="settings-toggle" id="settingsButton">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </button>

    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay">
        <div class="sidebar-close" id="sidebarClose">&times;</div>
        
        <!-- Connection Panel -->
        <div class="panel">
            <h3 class="text-lg font-bold mb-3 text-gray-200">Connection</h3>
            <label for="wsUrl" class="block text-sm font-medium text-gray-300 mb-1">WebSocket URL:</label>
            <input type="text" id="wsUrl" value="ws://localhost:8080/ws" class="mb-3">
            <button id="connectButton" class="btn-primary w-full">Connect</button>
        </div>

        <!-- Controls Panel -->
        <div id="controls" class="hidden">
            <!-- Chat Input -->
            <div class="panel">
                <h3 class="text-lg font-bold mb-3 text-gray-200">Chat</h3>
                <input type="text" id="chatInput" placeholder="Type a message..." class="mb-3">
                <button id="sendChatButton" class="btn-primary w-full">Send Chat</button>
            </div>

            <!-- Game Controls -->
            <div class="panel">
                <h3 class="text-lg font-bold mb-3 text-gray-200">Controls</h3>
                <ul class="text-sm text-gray-300 space-y-1">
                    <li>WASD - Move</li>
                    <li>Mouse - Aim</li>
                    <li>Left Click - Shoot</li>
                    <li>R - Reload</li>
                    <li>V - Melee Attack</li>
                    <li>Tab - Scoreboard</li>
                    <li>Esc - Settings</li>
                </ul>
            </div>

            <!-- Game Stats -->
            <div class="panel">
                <h3 class="text-lg font-bold mb-3 text-gray-200">Game Stats</h3>
                <div id="gameStats" class="text-sm text-gray-300 space-y-1">
                    <p>My ID: <span id="myPlayerIdSpan" class="text-indigo-300">N/A</span></p>
                    <p>Team: <span id="playerTeam" class="text-gray-100">None</span></p>
                    <p>Health: <span id="playerHealth" class="text-green-400">100</span></p>
                    <p>Shield: <span id="playerShield" class="text-blue-400">0</span></p>
                    <p>Ammo: <span id="playerAmmo" class="text-yellow-400">10</span> <span id="reloadPrompt" class="text-red-500 font-bold"></span></p>
                    <p>Weapon: <span id="playerWeapon" class="text-gray-100">Pistol</span></p>
                    <p>Score: <span id="playerScore" class="text-purple-400">0</span></p>
                    <p>K/D: <span id="playerKills" class="text-red-400">0</span>/<span id="playerDeaths" class="text-gray-400">0</span></p>
                    <p>Players: <span id="playerCount" class="text-gray-100">0</span></p>
                    <p>Ping: <span id="pingDisplay" class="text-gray-100">0</span>ms</p>
                </div>
                <div id="powerupStatus" class="mt-2 space-y-1"></div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="panel">
            <h3 class="text-lg font-bold mb-3 text-gray-200">Log</h3>
            <div id="log" style="max-height: 200px; overflow-y: auto;">
            </div>
        </div>
    </div>

    <!-- Game UI Overlays -->
    <div id="fpsCounter" class="fps-counter hidden">FPS: <span id="fpsValue">0</span></div>
    <div id="killFeed" class="kill-feed hidden"></div>
    <div id="chatDisplay" class="chat-display hidden"></div>
    <div id="matchInfo" class="match-info hidden"></div>
    <div id="minimapContainer"></div>
    <div id="networkQualityIndicator"></div>

    <!-- Scoreboard -->
    <div id="scoreboard" class="scoreboard hidden">
        <div class="scoreboard-header">
            <h3>Match Scoreboard</h3>
            <div class="close-btn" onclick="toggleScoreboard(false)">Ã—</div>
        </div>
        <div id="scoreboardContent" class="scoreboard-teams">
            <div id="ffaScoreboardSection" class="team-section hidden">
                <h4>Free For All</h4>
                <table id="ffaPlayersTable">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Score</th>
                            <th>Kills</th>
                            <th>Deaths</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div id="teamScoreboardSection" class="hidden">
                <div class="team-section team-red">
                    <h4>Red Team: <span id="scoreboardTeamRedScore">0</span></h4>
                    <table id="redTeamPlayers">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Score</th>
                                <th>Kills</th>
                                <th>Deaths</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div class="team-section team-blue">
                    <h4>Blue Team: <span id="scoreboardTeamBlueScore">0</span></h4>
                    <table id="blueTeamPlayers">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Score</th>
                                <th>Kills</th>
                                <th>Deaths</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="settings-menu hidden">
        <h3>Game Settings</h3>
        <div class="setting-group">
            <h4>Audio</h4>
            <label class="block mb-2">
                <input type="checkbox" id="soundEnabled" checked> Sound Effects
            </label>
            <label class="block mb-2">
                Volume: <input type="range" id="soundVolume" min="0" max="100" value="50" style="width: 60%;">
                <span id="soundVolumeValue">50</span>%
            </label>
            <label class="block mb-2">
                <input type="checkbox" id="musicEnabled"> Music
            </label>
            <label class="block mb-2">
                Volume: <input type="range" id="musicVolume" min="0" max="100" value="30" style="width: 60%;">
                <span id="musicVolumeValue">30</span>%
            </label>
        </div>
        <div class="setting-group">
            <h4>Graphics</h4>
            <label class="block mb-2">
                Quality:
                <select id="graphicsQuality" style="width: auto; padding: 4px 8px;">
                    <option value="low">Low</option>
                    <option value="medium" selected>Medium</option>
                    <option value="high">High</option>
                </select>
            </label>
            <label class="block mb-2">
                <input type="checkbox" id="particleEffects" checked> Particle Effects
            </label>
            <label class="block mb-2">
                <input type="checkbox" id="screenShake" checked> Screen Shake
            </label>
            <label class="block mb-2">
                <input type="checkbox" id="showFPS"> Show FPS
            </label>
        </div>
        <div class="setting-group">
            <h4>Controls</h4>
            <label class="block mb-2">
                Mouse Sensitivity: <input type="range" id="sensitivity" min="0.1" max="3" step="0.1" value="1.0" style="width: 60%;">
                <span id="sensitivityValue">1.0</span>
            </label>
        </div>
        <div class="flex justify-end mt-6 gap-3">
            <button id="saveSettingsButton" class="btn-primary">Save & Close</button>
            <button id="cancelSettingsButton" class="btn-secondary">Cancel</button>
        </div>
    </div>

    <script type="module">
        import * as flatbuffers from 'flatbuffers';
        import { GameProtocol } from './generated_js/game.js';
        const GP = GameProtocol;

        // Game constants
        const INTERPOLATION_DELAY = 100; // ms
        const INPUT_SEND_RATE = 60; // Hz
        const RECONCILIATION_BUFFER_SIZE = 120;
        const PLAYER_RADIUS = 15;
        const PICKUP_RADIUS = 20;
        const MIN_PLAYERS_TO_START = 2;
        const MAX_CHAT_MESSAGE_LENGTH = 100;
        const SERVER_TICK_RATE = 60;
        const VIEW_DISTANCE_BUFFER = 150;

        // Team colors
        const teamColors = {
            0: 0xA0A0A0, // Neutral/FFA
            1: 0xFF6B6B, // Team 1 - Red
            2: 0x4ECDC4, // Team 2 - Teal/Blue
        };
        const defaultEnemyColor = 0xF87171;

        // Weapon data
        const weaponNames = {
            [GP.WeaponType.Pistol]: 'Pistol',
            [GP.WeaponType.Shotgun]: 'Shotgun',
            [GP.WeaponType.Rifle]: 'Rifle',
            [GP.WeaponType.Sniper]: 'Sniper',
            [GP.WeaponType.Melee]: 'Melee'
        };

        const weaponColors = {
            [GP.WeaponType.Pistol]: 0xFFBF00,
            [GP.WeaponType.Shotgun]: 0xFF4444,
            [GP.WeaponType.Rifle]: 0x4444FF,
            [GP.WeaponType.Sniper]: 0xAA44FF,
            [GP.WeaponType.Melee]: 0xD1D5DB
        };

        // Pickup data
        const pickupTypes = {
            [GP.PickupType.Health]: 'Health',
            [GP.PickupType.Ammo]: 'Ammo',
            [GP.PickupType.WeaponCrate]: 'Weapon',
            [GP.PickupType.SpeedBoost]: 'Speed',
            [GP.PickupType.DamageBoost]: 'Damage',
            [GP.PickupType.Shield]: 'Shield',
            [GP.PickupType.FlagRed]: 'Red Flag',
            [GP.PickupType.FlagBlue]: 'Blue Flag'
        };

        const pickupColors = {
            [GP.PickupType.Health]: 0x10B981,
            [GP.PickupType.Ammo]: 0xF59E0B,
            [GP.PickupType.WeaponCrate]: 0x60A5FA,
            [GP.PickupType.SpeedBoost]: 0x00FFFF,
            [GP.PickupType.DamageBoost]: 0xFF6B6B,
            [GP.PickupType.Shield]: 0x00BFFF,
            [GP.PickupType.FlagRed]: 0xFF0000,
            [GP.PickupType.FlagBlue]: 0x0000FF
        };

        // DOM Elements
        const wsUrlInput = document.getElementById('wsUrl');
        const connectButton = document.getElementById('connectButton');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const logOutput = document.getElementById('log');
        const controlsDiv = document.getElementById('controls');
        const killFeedDiv = document.getElementById('killFeed');
        const chatDisplayDiv = document.getElementById('chatDisplay');
        const matchInfoDiv = document.getElementById('matchInfo');
        const pingDisplay = document.getElementById('pingDisplay');
        const networkQualityIndicatorDiv = document.getElementById('networkQualityIndicator');
        const settingsButton = document.getElementById('settingsButton');
        const settingsMenuDiv = document.getElementById('settingsMenu');
        const saveSettingsButton = document.getElementById('saveSettingsButton');
        const cancelSettingsButton = document.getElementById('cancelSettingsButton');
        const scoreboardDiv = document.getElementById('scoreboard');
        const fpsCounterDiv = document.getElementById('fpsCounter');
        const fpsValueSpan = document.getElementById('fpsValue');

        // Sidebar elements
        const menuToggle = document.getElementById('menuToggle');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        const sidebarClose = document.getElementById('sidebarClose');

        // Game Stats UI Elements
        const myPlayerIdSpan = document.getElementById('myPlayerIdSpan');
        const playerTeamSpan = document.getElementById('playerTeam');
        const playerHealthSpan = document.getElementById('playerHealth');
        const playerShieldSpan = document.getElementById('playerShield');
        const playerAmmoSpan = document.getElementById('playerAmmo');
        const reloadPromptSpan = document.getElementById('reloadPrompt');
        const playerWeaponSpan = document.getElementById('playerWeapon');
        const playerScoreSpan = document.getElementById('playerScore');
        const playerKillsSpan = document.getElementById('playerKills');
        const playerDeathsSpan = document.getElementById('playerDeaths');
        const playerCountSpan = document.getElementById('playerCount');
        const powerupStatusDiv = document.getElementById('powerupStatus');

        // WebRTC & WebSocket Variables
        let signalingSocket;
        let peerConnection;
        let dataChannel;

        // PIXI.js Application
        let app;
        let gameScene;
        let worldContainer;
        let hudContainer;
        let wallGraphics;
        let pickupContainer;
        let projectileContainer;
        let playerContainer;
        let flagContainer;
        let localPlayerSprite;

        // Game State
        let myPlayerId = null;
        let players = new Map();
        let projectiles = new Map();
        let walls = new Map();
        let pickups = new Map();
        let flagStates = new Map();
        let killFeed = [];
        let chatMessages = [];
        let matchInfo = null;
        let currentMapName = "Unknown Map";

        // Client-side prediction state
        let inputSequence = 0;
        let pendingInputs = [];
        let lastProcessedInput = 0;
        let localPlayerState = null;

        // Interpolation state
        let serverUpdates = [];
        let renderTimestamp = 0;

        // Input state
        let inputState = {
            move_forward: false,
            move_backward: false,
            move_left: false,
            move_right: false,
            shooting: false,
            reload: false,
            rotation: 0,
            melee_attack: false,
            change_weapon_slot: 0,
            use_ability_slot: 0
        };

        // Timing
        let lastInputSendTime = 0;
        let pingStartTime = 0;
        let ping = 0;
        let frameCount = 0;
        let lastFPSUpdate = 0;

        // Game Settings
        let gameSettings = {
            soundEnabled: true,
            soundVolume: 0.5,
            musicEnabled: false,
            musicVolume: 0.3,
            graphicsQuality: 'medium',
            showFPS: false,
            sensitivity: 1.0,
            particleEffects: true,
            screenShake: true
        };

        const peerConnectionConfig = {
            'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }]
        };

        // Sidebar toggle functionality
        menuToggle.addEventListener('click', () => {
            sidebarOverlay.classList.add('active');
        });

        sidebarClose.addEventListener('click', () => {
            sidebarOverlay.classList.remove('active');
        });

        // Close sidebar when clicking outside
        document.addEventListener('click', (e) => {
            if (!sidebarOverlay.contains(e.target) && !menuToggle.contains(e.target) && sidebarOverlay.classList.contains('active')) {
                sidebarOverlay.classList.remove('active');
            }
        });

        // Utility function to mix colors
        function mixColors(color1, color2, amount) {
            const c1 = PIXI.Color.shared.setValue(color1).toRgbArray();
            const c2 = PIXI.Color.shared.setValue(color2).toRgbArray();
            const r = c1[0] * (1 - amount) + c2[0] * amount;
            const g = c1[1] * (1 - amount) + c2[1] * amount;
            const b = c1[2] * (1 - amount) + c2[2] * amount;
            return PIXI.Color.shared.setValue([r, g, b]).toNumber();
        }

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.classList.add('log-entry', `log-${type}`);
            logOutput.appendChild(entry);
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        // Initialize PIXI Application
        function initPixi() {
            const pixiContainer = document.getElementById('pixiContainer');
            if (!pixiContainer) {
                log('CRITICAL ERROR: pixiContainer DOM element not found!', 'error');
                return;
            }

            app = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x0a0a0a,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                resizeTo: window
            });
            pixiContainer.appendChild(app.view);

            app.ticker.maxFPS = 60;

            if (!app || !app.stage) {
                log('CRITICAL ERROR: PIXI Application failed to initialize!', 'error');
                return;
            }

            // Main scene container (moves with camera)
            gameScene = new PIXI.Container();
            app.stage.addChild(gameScene);

            // World container (children are in world coordinates)
            worldContainer = new PIXI.Container();
            gameScene.addChild(worldContainer);

            wallGraphics = new PIXI.Graphics();
            pickupContainer = new PIXI.Container();
            projectileContainer = new PIXI.Container();
            playerContainer = new PIXI.Container();
            flagContainer = new PIXI.Container();

            worldContainer.addChild(wallGraphics);
            worldContainer.addChild(pickupContainer);
            worldContainer.addChild(projectileContainer);
            worldContainer.addChild(playerContainer);
            worldContainer.addChild(flagContainer);

            // HUD container (fixed on screen)
            hudContainer = new PIXI.Container();
            app.stage.addChild(hudContainer);

            app.ticker.add(gameLoop);
            log('PIXI scene graph initialized and ticker started.', 'info');
        }

        // Create player sprite
        function createPlayerSprite(player, isLocal = false) {
            const container = new PIXI.Container();
            container.playerId = player.id;

            // Shadow
            const shadow = new PIXI.Graphics();
            shadow.beginFill(0x000000, 0.3);
            shadow.drawEllipse(0, 8, PLAYER_RADIUS * 1.1, PLAYER_RADIUS * 0.6);
            shadow.endFill();
            shadow.filters = [new PIXI.BlurFilter(2)];
            container.addChild(shadow);

            // Body
            const body = new PIXI.Graphics();
            const playerTeamColor = teamColors[player.team_id] || teamColors[0];
            const mainBodyColor = player.alive ? playerTeamColor : 0x6B7280;

            body.lineStyle(2, 0x000000);
            body.beginFill(0xFFFFFF);
            const shipPoints = [0, -PLAYER_RADIUS * 1.2, PLAYER_RADIUS * 0.8, PLAYER_RADIUS * 0.8,
                PLAYER_RADIUS * 0.3, PLAYER_RADIUS * 0.4, 0, PLAYER_RADIUS * 0.6,
                -PLAYER_RADIUS * 0.3, PLAYER_RADIUS * 0.4, -PLAYER_RADIUS * 0.8, PLAYER_RADIUS * 0.8];
            body.drawPolygon(shipPoints);
            body.endFill();
            body.tint = mainBodyColor;
            container.addChild(body);
            container.body = body;

            // Local Player Indicator
            if (isLocal) {
                const localIndicator = new PIXI.Graphics();
                localIndicator.lineStyle(2, 0xFFD700, 0.7);
                localIndicator.drawCircle(0, 0, PLAYER_RADIUS + 4);
                container.addChild(localIndicator);
                container.localIndicator = localIndicator;
            }

            // Gun
            const gun = new PIXI.Container();
            gun.rotation = -Math.PI / 2;
            container.addChild(gun);
            container.gun = gun;

            // Health Bar Container
            const healthBarContainer = new PIXI.Container();
            healthBarContainer.position.set(0, -PLAYER_RADIUS - 15);

            const healthBg = new PIXI.Graphics();
            healthBg.beginFill(0x1F2937, 0.9);
            healthBg.drawRoundedRect(-PLAYER_RADIUS - 2, -2, PLAYER_RADIUS * 2 + 4, 10, 5);
            healthBarContainer.addChild(healthBg);

            const healthBorder = new PIXI.Graphics();
            healthBorder.lineStyle(1, 0x4B5563, 0.8);
            healthBorder.drawRoundedRect(-PLAYER_RADIUS - 2, -2, PLAYER_RADIUS * 2 + 4, 10, 5);
            healthBarContainer.addChild(healthBorder);

            const healthFg = new PIXI.Graphics();
            healthFg.beginFill(0x22C55E);
            healthFg.drawRoundedRect(-PLAYER_RADIUS, 0, PLAYER_RADIUS * 2, 6, 3);
            healthFg.endFill();
            healthBarContainer.addChild(healthFg);

            container.addChild(healthBarContainer);
            container.healthBarContainer = healthBarContainer;
            container.healthFg = healthFg;

            // Username Text
            const usernameStyle = new PIXI.TextStyle({
                fontFamily: 'Arial', fontSize: 12, fill: [0xFFFFFF, 0xE5E7EB],
                stroke: 0x111827, strokeThickness: 3,
                dropShadow: true, dropShadowColor: 0x000000, dropShadowBlur: 3, dropShadowDistance: 1,
                align: 'center'
            });
            const usernameText = new PIXI.Text(player.username || 'Player', usernameStyle);
            usernameText.anchor.set(0.5);
            usernameText.position.y = -PLAYER_RADIUS - 28;
            container.addChild(usernameText);
            container.usernameText = usernameText;

            return container;
        }

        // FIXED: Create projectile sprite with proper animation support
        function createProjectileSprite(projectile) {
            const container = new PIXI.Container();
            container.projectileId = projectile.id;

            const projectileConfigs = {
                [GP.WeaponType.Pistol]: {
                    color: 0xFFBF00,
                    glowColor: 0xFFFF00,
                    size: 8,
                    glowSize: 15,
                    shape: 'bullet',
                    speed: 600
                },
                [GP.WeaponType.Shotgun]: {
                    color: 0xFF4444,
                    glowColor: 0xFF6666,
                    size: 4,
                    glowSize: 8,
                    shape: 'pellet',
                    speed: 500
                },
                [GP.WeaponType.Rifle]: {
                    color: 0x4444FF,
                    glowColor: 0x6666FF,
                    size: 10,
                    glowSize: 18,
                    shape: 'laser',
                    speed: 800
                },
                [GP.WeaponType.Sniper]: {
                    color: 0xAA44FF,
                    glowColor: 0xFF00FF,
                    size: 12,
                    glowSize: 20,
                    shape: 'beam',
                    speed: 1000
                }
            };

            const config = projectileConfigs[projectile.weapon_type] || projectileConfigs[GP.WeaponType.Pistol];

            // Outer glow effect
            const glow = new PIXI.Graphics();
            glow.beginFill(config.glowColor, 0.4);
            glow.drawCircle(0, 0, config.glowSize);
            glow.endFill();
            glow.filters = [new PIXI.BlurFilter(4)];
            container.addChild(glow);

            // Core projectile
            const core = new PIXI.Graphics();

            switch (config.shape) {
                case 'pellet':
                    core.beginFill(config.color, 1);
                    core.drawCircle(0, 0, config.size);
                    core.endFill();
                    core.beginFill(0xFFFFFF, 0.8);
                    core.drawCircle(0, 0, config.size * 0.5);
                    core.endFill();
                    break;

                case 'laser':
                    core.beginFill(config.color, 0.9);
                    core.drawRoundedRect(-config.size * 1.5, -config.size / 3, config.size * 3, config.size * 0.66, config.size / 3);
                    core.endFill();
                    core.beginFill(0xFFFFFF, 1);
                    core.drawRoundedRect(-config.size * 1.2, -config.size / 6, config.size * 2.4, config.size / 3, config.size / 6);
                    core.endFill();
                    break;

                case 'beam':
                    core.beginFill(config.color, 0.8);
                    core.drawRect(-config.size * 3, -2, config.size * 6, 4);
                    core.endFill();
                    core.beginFill(0xFFFFFF, 1);
                    core.drawRect(-config.size * 3, -1, config.size * 6, 2);
                    core.endFill();
                    break;

                default: // bullet
                    core.beginFill(config.color, 1);
                    core.drawRoundedRect(-config.size / 2, -config.size / 3, config.size * 1.5, config.size * 0.66, config.size / 3);
                    core.endFill();
                    core.beginFill(0xFFFFFF, 1);
                    core.drawCircle(config.size * 0.5, 0, config.size / 3);
                    core.endFill();
            }

            container.addChild(core);

            // Add motion trail effect
            const trail = new PIXI.Graphics();
            trail.alpha = 0.5;
            container.addChildAt(trail, 0);
            container.trail = trail;

            // Store config for trail updates
            container.trailColor = config.glowColor;
            container.weaponType = projectile.weapon_type;
            container.config = config;

            // Initialize position history for smooth trail
            container.positionHistory = [];

            return container;
        }

        // FIXED: Update projectile sprite with smooth animation
        function updateProjectileSprite(sprite, projectile) {
            // Use interpolated position if available, otherwise use actual position
            const x = projectile.render_x !== undefined ? projectile.render_x : projectile.x;
            const y = projectile.render_y !== undefined ? projectile.render_y : projectile.y;
            
            sprite.position.x = x;
            sprite.position.y = y;

            // Update rotation based on velocity
            if (projectile.velocity_x !== undefined && projectile.velocity_y !== undefined) {
                sprite.rotation = Math.atan2(projectile.velocity_y, projectile.velocity_x);
            }

            // Update position history for trail
            sprite.positionHistory.push({ x, y });
            if (sprite.positionHistory.length > 10) {
                sprite.positionHistory.shift();
            }

            // Draw trail
            if (sprite.trail && sprite.positionHistory.length > 1) {
                sprite.trail.clear();
                
                for (let i = 0; i < sprite.positionHistory.length - 1; i++) {
                    const alpha = (i / sprite.positionHistory.length) * 0.5;
                    const thickness = 3 - (i / sprite.positionHistory.length) * 2;
                    
                    sprite.trail.lineStyle(thickness, sprite.trailColor, alpha);
                    
                    if (i === 0) {
                        sprite.trail.moveTo(
                            sprite.positionHistory[i].x - x,
                            sprite.positionHistory[i].y - y
                        );
                    }
                    
                    sprite.trail.lineTo(
                        sprite.positionHistory[i + 1].x - x,
                        sprite.positionHistory[i + 1].y - y
                    );
                }
            }
        }

        // Update player sprite
        function updatePlayerSprite(sprite, player) {
            sprite.position.x = player.render_x !== undefined ? player.render_x : player.x;
            sprite.position.y = player.render_y !== undefined ? player.render_y : player.y;

            let effectiveRotation = (player.render_rotation !== undefined ? player.render_rotation : player.rotation) + (Math.PI / 2);
            sprite.rotation = effectiveRotation;

            // Update body tint
            const playerTeamColor = teamColors[player.team_id] || teamColors[0];
            const mainBodyColor = player.alive ? playerTeamColor : 0x6B7280;
            sprite.body.tint = mainBodyColor;

            if (sprite.localIndicator) {
                sprite.localIndicator.visible = (sprite.playerId === myPlayerId && player.alive);
            }

            sprite.visible = player.alive || (player.respawn_timer !== undefined && player.respawn_timer > 0);
            sprite.alpha = player.alive ? 1 : 0.5;

            updatePlayerHealthBar(sprite, player);

            if (sprite.usernameText.text !== (player.username || 'Player')) {
                sprite.usernameText.text = player.username || 'Player';
            }
        }

        function updatePlayerHealthBar(sprite, player) {
            if (!sprite.healthFg || !sprite.healthBarContainer) return;

            if (player.alive) {
                sprite.healthBarContainer.visible = true;
                const healthPercent = Math.max(0, Math.min(1, player.health / player.max_health));
                sprite.healthFg.scale.x = healthPercent;

                let healthColor;
                if (healthPercent > 0.6) {
                    healthColor = interpolateColor(0x22C55E, 0xFACC15, (healthPercent - 0.6) / 0.4);
                } else if (healthPercent > 0.3) {
                    healthColor = interpolateColor(0xFACC15, 0xEF4444, (healthPercent - 0.3) / 0.3);
                } else {
                    healthColor = 0xEF4444;
                }
                sprite.healthFg.tint = healthColor;

                if (healthPercent < 0.3) {
                    const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                    sprite.healthFg.alpha = pulse;
                } else {
                    sprite.healthFg.alpha = 1;
                }
            } else {
                sprite.healthBarContainer.visible = false;
            }
        }

        // Helper function to interpolate colors
        function interpolateColor(color1, color2, factor) {
            const c1 = PIXI.Color.shared.setValue(color1).toRgbArray();
            const c2 = PIXI.Color.shared.setValue(color2).toRgbArray();
            const r = Math.floor(c1[0] * 255 * (1 - factor) + c2[0] * 255 * factor);
            const g = Math.floor(c1[1] * 255 * (1 - factor) + c2[1] * 255 * factor);
            const b = Math.floor(c1[2] * 255 * (1 - factor) + c2[2] * 255 * factor);
            return (r << 16) | (g << 8) | b;
        }

        // Update camera
        function updateCamera() {
            if (localPlayerState && app && gameScene) {
                const targetX = app.screen.width / 2 - (localPlayerState.render_x !== undefined ? localPlayerState.render_x : localPlayerState.x);
                const targetY = app.screen.height / 2 - (localPlayerState.render_y !== undefined ? localPlayerState.render_y : localPlayerState.y);

                const smoothing = 0.1;
                gameScene.position.x += (targetX - gameScene.position.x) * smoothing;
                gameScene.position.y += (targetY - gameScene.position.y) * smoothing;
            }
        }

        // FIXED: Main game loop with proper projectile prediction
        function gameLoop(delta) {
            const currentTime = Date.now();
            renderTimestamp = currentTime - INTERPOLATION_DELAY;

            // Update FPS
            frameCount++;
            if (currentTime - lastFPSUpdate >= 1000) {
                fpsValueSpan.textContent = frameCount;
                frameCount = 0;
                lastFPSUpdate = currentTime;
            }

            if (localPlayerState && localPlayerState.alive) {
                updateLocalPlayerPrediction(app.ticker.deltaMS / 1000);
            }

            interpolateEntities();

            // FIXED: Smooth client-side prediction for projectiles
            const clientDeltaTime = app.ticker.deltaMS / 1000;
            projectiles.forEach((proj, projId) => {
                // Only predict for projectiles that have velocity data
                if (proj.velocity_x !== undefined && proj.velocity_y !== undefined) {
                    // If we don't have interpolated position yet, predict from base position
                    if (proj.render_x === undefined) {
                        proj.render_x = proj.x;
                    }
                    if (proj.render_y === undefined) {
                        proj.render_y = proj.y;
                    }
                    
                    // Apply velocity to render position for smooth movement
                    proj.render_x += proj.velocity_x * clientDeltaTime;
                    proj.render_y += proj.velocity_y * clientDeltaTime;
                }
            });

            updateSprites();
            updateCamera();

            sendInputsToServer();
            updateGameStatsUI();
        }

        // Client-side prediction
        function updateLocalPlayerPrediction(deltaTime) {
            if (!localPlayerState || !localPlayerState.alive) return;

            let moveXIntent = 0;
            let moveYIntent = 0;
            if (inputState.move_forward) moveYIntent -= 1;
            if (inputState.move_backward) moveYIntent += 1;
            if (inputState.move_left) moveXIntent -= 1;
            if (inputState.move_right) moveXIntent += 1;

            const effectiveSpeed = localPlayerState.speed_boost_remaining > 0 ? 225 : 150;

            if (moveXIntent !== 0 || moveYIntent !== 0) {
                const magnitude = Math.sqrt(moveXIntent * moveXIntent + moveYIntent * moveYIntent);
                localPlayerState.x += (moveXIntent / magnitude) * effectiveSpeed * deltaTime;
                localPlayerState.y += (moveYIntent / magnitude) * effectiveSpeed * deltaTime;
            }

            localPlayerState.rotation = inputState.rotation;
            localPlayerState.render_x = localPlayerState.x;
            localPlayerState.render_y = localPlayerState.y;
            localPlayerState.render_rotation = localPlayerState.rotation;
        }

        // FIXED: Enhanced interpolation for smooth projectile movement
        function interpolateEntities() {
            const now = Date.now();
            const renderTime = now - INTERPOLATION_DELAY;

            serverUpdates = serverUpdates.filter(update => update.timestamp > renderTime - 500);

            if (serverUpdates.length < 2) return;

            let update1 = null, update2 = null;
            for (let i = serverUpdates.length - 1; i >= 1; i--) {
                if (serverUpdates[i].timestamp >= renderTime && serverUpdates[i - 1].timestamp <= renderTime) {
                    update2 = serverUpdates[i];
                    update1 = serverUpdates[i - 1];
                    break;
                }
            }

            if (!update1 && serverUpdates[0].timestamp <= renderTime && serverUpdates.length > 0) {
                update1 = serverUpdates[0];
                update2 = serverUpdates[0];
            } else if (!update1 || !update2) {
                return;
            }

            const t = (update1.timestamp === update2.timestamp) ? 1 : (renderTime - update1.timestamp) / (update2.timestamp - update1.timestamp);
            const clampedT = Math.max(0, Math.min(1, t));

            // Interpolate players
            players.forEach((currentPlayerState, playerId) => {
                if (playerId === myPlayerId) return;

                const state1 = update1.players.get(playerId);
                const state2 = update2.players.get(playerId);

                if (state1 && state2) {
                    currentPlayerState.render_x = state1.x + (state2.x - state1.x) * clampedT;
                    currentPlayerState.render_y = state1.y + (state2.y - state1.y) * clampedT;

                    let rotDiff = state2.rotation - state1.rotation;
                    while (rotDiff > Math.PI) rotDiff -= 2 * Math.PI;
                    while (rotDiff < -Math.PI) rotDiff += 2 * Math.PI;
                    currentPlayerState.render_rotation = state1.rotation + rotDiff * clampedT;
                } else if (state2) {
                    currentPlayerState.render_x = state2.x;
                    currentPlayerState.render_y = state2.y;
                    currentPlayerState.render_rotation = state2.rotation;
                }
            });

            // FIXED: Interpolate projectiles with velocity consideration
            projectiles.forEach((currentProjState, projId) => {
                const state1 = update1.projectiles.get(projId);
                const state2 = update2.projectiles.get(projId);

                if (state1 && state2) {
                    // Interpolate between known positions
                    const interpX = state1.x + (state2.x - state1.x) * clampedT;
                    const interpY = state1.y + (state2.y - state1.y) * clampedT;
                    
                    // Use interpolated position as base
                    currentProjState.render_x = interpX;
                    currentProjState.render_y = interpY;
                    
                    // Store velocity for client-side prediction
                    if (state2.velocity_x !== undefined) {
                        currentProjState.velocity_x = state2.velocity_x;
                        currentProjState.velocity_y = state2.velocity_y;
                    }
                } else if (state2) {
                    currentProjState.render_x = state2.x;
                    currentProjState.render_y = state2.y;
                    if (state2.velocity_x !== undefined) {
                        currentProjState.velocity_x = state2.velocity_x;
                        currentProjState.velocity_y = state2.velocity_y;
                    }
                }
            });
        }

        function updateSprites() {
            // Update player sprites
            players.forEach((player, playerId) => {
                let sprite = playerContainer.children.find(s => s.playerId === playerId);
                if (!sprite) {
                    sprite = createPlayerSprite(player, playerId === myPlayerId);
                    playerContainer.addChild(sprite);
                    if (playerId === myPlayerId) localPlayerSprite = sprite;
                }
                updatePlayerSprite(sprite, player);
            });

            // Remove sprites for disconnected players
            for (let i = playerContainer.children.length - 1; i >= 0; i--) {
                const sprite = playerContainer.children[i];
                if (!players.has(sprite.playerId)) {
                    sprite.destroy({ children: true });
                }
            }

            // Update projectile sprites
            projectiles.forEach((projectile, projectileId) => {
                let sprite = projectileContainer.children.find(s => s.projectileId === projectileId);
                if (!sprite) {
                    sprite = createProjectileSprite(projectile);
                    projectileContainer.addChild(sprite);
                }
                updateProjectileSprite(sprite, projectile);
            });

            // Remove sprites for expired projectiles
            for (let i = projectileContainer.children.length - 1; i >= 0; i--) {
                const sprite = projectileContainer.children[i];
                if (!projectiles.has(sprite.projectileId)) {
                    sprite.destroy({ children: true });
                }
            }
        }

        // Process server update
        function processServerUpdate(messageData, isInitial = false) {
            if (!messageData) {
                log(`[processServerUpdate] Error: messageData is ${messageData}. isInitial: ${isInitial}`, 'error');
                return;
            }

            const serverTime = Number(messageData.timestamp);

            if (isInitial) {
                walls.clear();
                if (messageData.walls) {
                    messageData.walls.forEach(wallData => walls.set(wallData.id, wallData));
                }
                drawWalls();
                if (messageData.map_name) currentMapName = messageData.map_name;
            }

            // Update players
            if (messageData.players) {
                messageData.players.forEach(pData => {
                    players.set(pData.id, pData);

                    if (pData.id === myPlayerId) {
                        if (!localPlayerState) {
                            localPlayerState = { ...pData };
                        } else {
                            Object.assign(localPlayerState, pData);
                        }
                        if (messageData.last_processed_input_sequence !== undefined && messageData.last_processed_input_sequence !== null) {
                            lastProcessedInput = Number(messageData.last_processed_input_sequence);
                            if (!isNaN(lastProcessedInput)) {
                                pendingInputs = pendingInputs.filter(inp => inp.sequence > lastProcessedInput);
                            }
                        }
                        localPlayerState.render_x = localPlayerState.x;
                        localPlayerState.render_y = localPlayerState.y;
                        localPlayerState.render_rotation = localPlayerState.rotation;
                    }
                });
            }

            if (messageData.removed_player_ids && messageData.removed_player_ids.length > 0) {
                messageData.removed_player_ids.forEach(removedId => {
                    players.delete(removedId);
                    log(`Player ${removedId} removed.`, 'info');
                });
            }

            // Update projectiles
            if (messageData.projectiles) {
                messageData.projectiles.forEach(pData => projectiles.set(pData.id, pData));
            }
            if (messageData.removed_projectiles) {
                messageData.removed_projectiles.forEach(id => projectiles.delete(id));
            }

            // Update kill feed
            if (messageData.kill_feed) {
                killFeed = messageData.kill_feed;
                updateKillFeed();
            }

            // Update match info
            if (messageData.match_info) {
                matchInfo = messageData.match_info;
                updateMatchInfo();
            }

            // Store for interpolation
            serverUpdates.push({
                timestamp: serverTime,
                players: new Map(players.entries()),
                projectiles: new Map(projectiles.entries())
            });
            serverUpdates = serverUpdates.filter(s => s.timestamp > Date.now() - 2000);
        }

        function drawWalls() {
            wallGraphics.clear();
            walls.forEach(wall => {
                wallGraphics.beginFill(0x374151);
                wallGraphics.drawRect(wall.x, wall.y, wall.width, wall.height);
                wallGraphics.endFill();
                wallGraphics.lineStyle(2, 0x1F2937, 1);
                wallGraphics.drawRect(wall.x, wall.y, wall.width, wall.height);
            });
        }

        // Parse FlatBuffer message
        function parseFlatBufferMessage(data) {
            try {
                const buf = new flatbuffers.ByteBuffer(new Uint8Array(data));
                const gameMsg = GameProtocol.GameMessage.getRootAsGameMessage(buf);
                const msgType = gameMsg.msgType();

                switch (msgType) {
                    case GameProtocol.MessageType.Welcome:
                        const welcome = gameMsg.actualMessage(new GP.WelcomeMessage());
                        if (!welcome) {
                            log('Failed to get WelcomeMessage from union', 'error');
                            return null;
                        }
                        return {
                            type: 'welcome',
                            playerId: welcome.playerId(),
                            message: welcome.message(),
                            serverTickRate: welcome.serverTickRate()
                        };

                    case GP.MessageType.InitialState:
                        const initial = gameMsg.actualMessage(new GP.InitialStateMessage());
                        if (!initial) {
                            log(`No InitialState payload for type ${msgType}`, 'error');
                            return null;
                        }
                        const initialStateData = {
                            player_id: initial.playerId(),
                            walls: [],
                            players: [],
                            projectiles: [],
                            timestamp: Number(initial.timestamp()),
                            map_name: initial.mapName()
                        };

                        // Parse walls
                        for (let i = 0; i < initial.wallsLength(); i++) {
                            const wall = initial.walls(i);
                            if (wall) {
                                initialStateData.walls.push({
                                    id: wall.id(),
                                    x: wall.x(),
                                    y: wall.y(),
                                    width: wall.width(),
                                    height: wall.height()
                                });
                            }
                        }

                        // Parse players
                        for (let i = 0; i < initial.playersLength(); i++) {
                            const p = initial.players(i);
                            if (p) {
                                initialStateData.players.push({
                                    id: p.id(),
                                    username: p.username(),
                                    x: p.x(),
                                    y: p.y(),
                                    rotation: p.rotation(),
                                    velocity_x: p.velocityX(),
                                    velocity_y: p.velocityY(),
                                    health: p.health(),
                                    max_health: p.maxHealth(),
                                    alive: p.alive(),
                                    respawn_timer: p.respawnTimer(),
                                    weapon: p.weapon(),
                                    ammo: p.ammo(),
                                    reload_progress: p.reloadProgress(),
                                    score: p.score(),
                                    kills: p.kills(),
                                    deaths: p.deaths(),
                                    team_id: p.teamId(),
                                    speed_boost_remaining: p.speedBoostRemaining(),
                                    damage_boost_remaining: p.damageBoostRemaining(),
                                    shield_current: p.shieldCurrent(),
                                    shield_max: p.shieldMax()
                                });
                            }
                        }

                        // Parse projectiles
                        for (let i = 0; i < initial.projectilesLength(); i++) {
                            const p = initial.projectiles(i);
                            if (p) {
                                initialStateData.projectiles.push({
                                    id: p.id(),
                                    x: p.x(),
                                    y: p.y(),
                                    owner_id: p.ownerId(),
                                    weapon_type: p.weaponType(),
                                    velocity_x: p.velocityX(),
                                    velocity_y: p.velocityY()
                                });
                            }
                        }

                        // Parse match info
                        const mi = initial.matchInfo();
                        if (mi) {
                            const teamScores = [];
                            for (let i = 0; i < mi.teamScoresLength(); i++) {
                                const ts = mi.teamScores(i);
                                if (ts) {
                                    teamScores.push({
                                        team_id: ts.teamId(),
                                        score: ts.score()
                                    });
                                }
                            }
                            initialStateData.match_info = {
                                time_remaining: mi.timeRemaining(),
                                match_state: mi.matchState(),
                                winner_id: mi.winnerId(),
                                winner_name: mi.winnerName(),
                                game_mode: mi.gameMode(),
                                team_scores: teamScores
                            };
                        }

                        return { type: 'initial', data: initialStateData };

                    case GP.MessageType.DeltaState:
                        const delta = gameMsg.actualMessage(new GP.DeltaStateMessage());
                        if (!delta) {
                            log(`No DeltaState payload for type ${msgType}`, 'error');
                            return null;
                        }
                        const deltaStateData = {
                            players: [],
                            projectiles: [],
                            removed_projectiles: [],
                            kill_feed: [],
                            match_info: null,
                            timestamp: Number(delta.timestamp()),
                            last_processed_input_sequence: delta.lastProcessedInputSequence(),
                            removed_player_ids: []
                        };

                        // Parse removed_player_ids if present
                        if (typeof delta.removedPlayerIdsLength === 'function') {
                            for (let i = 0; i < delta.removedPlayerIdsLength(); i++) {
                                const removedId = delta.removedPlayerIds(i);
                                if (removedId) {
                                    deltaStateData.removed_player_ids.push(removedId);
                                }
                            }
                        }

                        // Parse players
                        for (let i = 0; i < delta.playersLength(); i++) {
                            const p = delta.players(i);
                            if (p) {
                                deltaStateData.players.push({
                                    id: p.id(),
                                    username: p.username(),
                                    x: p.x(),
                                    y: p.y(),
                                    rotation: p.rotation(),
                                    velocity_x: p.velocityX(),
                                    velocity_y: p.velocityY(),
                                    health: p.health(),
                                    max_health: p.maxHealth(),
                                    alive: p.alive(),
                                    respawn_timer: p.respawnTimer(),
                                    weapon: p.weapon(),
                                    ammo: p.ammo(),
                                    reload_progress: p.reloadProgress(),
                                    score: p.score(),
                                    kills: p.kills(),
                                    deaths: p.deaths(),
                                    team_id: p.teamId(),
                                    speed_boost_remaining: p.speedBoostRemaining(),
                                    damage_boost_remaining: p.damageBoostRemaining(),
                                    shield_current: p.shieldCurrent(),
                                    shield_max: p.shieldMax()
                                });
                            }
                        }

                        // Parse projectiles
                        for (let i = 0; i < delta.projectilesLength(); i++) {
                            const p = delta.projectiles(i);
                            if (p) {
                                deltaStateData.projectiles.push({
                                    id: p.id(),
                                    x: p.x(),
                                    y: p.y(),
                                    owner_id: p.ownerId(),
                                    weapon_type: p.weaponType(),
                                    velocity_x: p.velocityX(),
                                    velocity_y: p.velocityY()
                                });
                            }
                        }

                        // Parse removed projectiles
                        for (let i = 0; i < delta.removedProjectilesLength(); i++) {
                            deltaStateData.removed_projectiles.push(delta.removedProjectiles(i));
                        }

                        // Parse kill feed
                        for (let i = 0; i < delta.killFeedLength(); i++) {
                            const kf = delta.killFeed(i);
                            if (kf) {
                                deltaStateData.kill_feed.push({
                                    killer_name: kf.killerName(),
                                    victim_name: kf.victimName(),
                                    weapon: kf.weapon(),
                                    timestamp: kf.timestamp()
                                });
                            }
                        }

                        // Parse match info
                        const dmi = delta.matchInfo();
                        if (dmi) {
                            const teamScores = [];
                            for (let i = 0; i < dmi.teamScoresLength(); i++) {
                                const ts = dmi.teamScores(i);
                                if (ts) {
                                    teamScores.push({
                                        team_id: ts.teamId(),
                                        score: ts.score()
                                    });
                                }
                            }
                            deltaStateData.match_info = {
                                time_remaining: dmi.timeRemaining(),
                                match_state: dmi.matchState(),
                                winner_id: dmi.winnerId(),
                                winner_name: dmi.winnerName(),
                                game_mode: dmi.gameMode(),
                                team_scores: teamScores
                            };
                        }

                        return { type: 'delta', data: deltaStateData };

                    case GP.MessageType.Chat:
                        const chat = gameMsg.actualMessage(new GP.ChatMessage());
                        if (!chat) {
                            log(`No Chat payload for type ${msgType}`, 'error');
                            return null;
                        }
                        return {
                            type: 'chat',
                            data: {
                                seq: Number(chat.seq()),
                                player_id: chat.playerId(),
                                username: chat.username(),
                                message: chat.message(),
                                timestamp: Number(chat.timestamp())
                            }
                        };

                    default:
                        log(`Received unknown message type: ${msgType}`, 'error');
                        return null;
                }
            } catch (e) {
                console.error('Error parsing FlatBuffer:', e, data);
                log(`Error parsing FlatBuffer: ${e.message}`, 'error');
                return null;
            }
        }

        // Create FlatBuffer messages
        function createInputMessage(currentInputState) {
            const builder = new flatbuffers.Builder(128);
            GP.PlayerInput.startPlayerInput(builder);
            GP.PlayerInput.addTimestamp(builder, BigInt(Date.now()));
            GP.PlayerInput.addSequence(builder, currentInputState.sequence);
            GP.PlayerInput.addMoveForward(builder, currentInputState.move_forward);
            GP.PlayerInput.addMoveBackward(builder, currentInputState.move_backward);
            GP.PlayerInput.addMoveLeft(builder, currentInputState.move_left);
            GP.PlayerInput.addMoveRight(builder, currentInputState.move_right);
            GP.PlayerInput.addShooting(builder, currentInputState.shooting);
            GP.PlayerInput.addReload(builder, currentInputState.reload);
            GP.PlayerInput.addRotation(builder, currentInputState.rotation);
            GP.PlayerInput.addMeleeAttack(builder, currentInputState.melee_attack);
            GP.PlayerInput.addChangeWeaponSlot(builder, currentInputState.change_weapon_slot);
            GP.PlayerInput.addUseAbilitySlot(builder, currentInputState.use_ability_slot);
            const playerInputOffset = GP.PlayerInput.endPlayerInput(builder);

            GP.GameMessage.startGameMessage(builder);
            GP.GameMessage.addMsgType(builder, GP.MessageType.Input);
            GP.GameMessage.addActualMessageType(builder, GP.MessagePayload.PlayerInput);
            GP.GameMessage.addActualMessage(builder, playerInputOffset);
            const gameMessageOffset = GP.GameMessage.endGameMessage(builder);
            builder.finish(gameMessageOffset);
            return builder.asUint8Array();
        }

        function createChatMessage(text) {
            const builder = new flatbuffers.Builder(256);
            const messageStr = builder.createString(text);
            const playerIdStr = builder.createString(myPlayerId || 'unknown');
            const usernameStr = builder.createString(localPlayerState?.username || 'Player');

            GP.ChatMessage.startChatMessage(builder);
            GP.ChatMessage.addSeq(builder, BigInt(0));
            GP.ChatMessage.addPlayerId(builder, playerIdStr);
            GP.ChatMessage.addUsername(builder, usernameStr);
            GP.ChatMessage.addMessage(builder, messageStr);
            GP.ChatMessage.addTimestamp(builder, BigInt(Date.now()));
            const chatMessageOffset = GP.ChatMessage.endChatMessage(builder);

            GP.GameMessage.startGameMessage(builder);
            GP.GameMessage.addMsgType(builder, GP.MessageType.Chat);
            GP.GameMessage.addActualMessageType(builder, GP.MessagePayload.ChatMessage);
            GP.GameMessage.addActualMessage(builder, chatMessageOffset);
            const gameMessageOffset = GP.GameMessage.endGameMessage(builder);
            builder.finish(gameMessageOffset);
            return builder.asUint8Array();
        }

        // Input handling
        function setupInputHandlers() {
            document.addEventListener('keydown', (e) => handleKeyInput(e, true));
            document.addEventListener('keyup', (e) => handleKeyInput(e, false));
            app.view.addEventListener('mousemove', handleMouseMove);
            app.view.addEventListener('mousedown', (e) => {
                if (e.button === 0) inputState.shooting = true;
            });
            app.view.addEventListener('mouseup', (e) => {
                if (e.button === 0) inputState.shooting = false;
            });
            app.view.oncontextmenu = (e) => e.preventDefault();

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleScoreboard();
                }
                if (e.key === 'Escape') {
                    e.preventDefault();
                    toggleSettings();
                }
            });
        }

        function handleKeyInput(event, isDown) {
            if (document.activeElement === chatInput || !settingsMenuDiv.classList.contains('hidden')) return;

            let gameKeyProcessed = true;
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    inputState.move_forward = isDown;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    inputState.move_backward = isDown;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    inputState.move_left = isDown;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    inputState.move_right = isDown;
                    break;
                case 'KeyR':
                    if (isDown) inputState.reload = true;
                    break;
                case 'KeyV':
                    if (isDown) inputState.melee_attack = true;
                    break;
                default:
                    gameKeyProcessed = false;
                    break;
            }
            if (gameKeyProcessed) event.preventDefault();
        }

        function handleMouseMove(event) {
            if (!app || !app.view || !localPlayerSprite || !localPlayerState) return;
            const rect = app.view.getBoundingClientRect();
            const mouseGlobal = new PIXI.Point(event.clientX - rect.left, event.clientY - rect.top);
            const mouseLocalToGameScene = gameScene.toLocal(mouseGlobal);

            const dx = mouseLocalToGameScene.x - (localPlayerState.render_x || localPlayerState.x);
            const dy = mouseLocalToGameScene.y - (localPlayerState.render_y || localPlayerState.y);
            inputState.rotation = Math.atan2(dy, dx) * gameSettings.sensitivity;
        }

        // Send inputs to server
        function sendInputsToServer() {
            if (!dataChannel || dataChannel.readyState !== 'open' || !localPlayerState || !localPlayerState.alive) return;

            const now = Date.now();
            if (now - lastInputSendTime < 1000 / INPUT_SEND_RATE) return;
            lastInputSendTime = now;

            const currentFrameInput = {
                timestamp: now,
                sequence: ++inputSequence,
                move_forward: inputState.move_forward,
                move_backward: inputState.move_backward,
                move_left: inputState.move_left,
                move_right: inputState.move_right,
                shooting: inputState.shooting,
                reload: inputState.reload,
                rotation: inputState.rotation,
                melee_attack: inputState.melee_attack,
                change_weapon_slot: inputState.change_weapon_slot,
                use_ability_slot: inputState.use_ability_slot,
            };

            pendingInputs.push(currentFrameInput);
            if (pendingInputs.length > RECONCILIATION_BUFFER_SIZE) pendingInputs.shift();

            const bytes = createInputMessage(currentFrameInput);
            dataChannel.send(bytes);

            // Reset one-time inputs
            if (inputState.reload) inputState.reload = false;
            if (inputState.melee_attack) inputState.melee_attack = false;
            if (inputState.change_weapon_slot !== 0) inputState.change_weapon_slot = 0;
            if (inputState.use_ability_slot !== 0) inputState.use_ability_slot = 0;
        }

        // UI Update functions
        function updateKillFeed() {
            killFeedDiv.innerHTML = '';
            if (killFeed.length > 0) {
                killFeedDiv.classList.remove('hidden');
                killFeed.slice(-5).reverse().forEach(entry => {
                    const div = document.createElement('div');
                    div.className = 'kill-entry';
                    div.innerHTML = `<span style="color:#FF6B6B;">${entry.killer_name}</span> [${weaponNames[entry.weapon] || 'Unknown'}] <span style="color:#4ECDC4;">${entry.victim_name}</span>`;
                    killFeedDiv.appendChild(div);
                });
            } else {
                killFeedDiv.classList.add('hidden');
            }
        }

        function updateChatDisplay() {
            chatDisplayDiv.innerHTML = '';
            if (chatMessages.length > 0) {
                chatDisplayDiv.classList.remove('hidden');
                chatMessages.slice(-10).forEach(msg => {
                    const div = document.createElement('div');
                    div.className = 'chat-entry';
                    const player = players.get(msg.player_id);
                    const nameColor = player ? (teamColors[player.team_id] || teamColors[0]) : teamColors[0];
                    const hexColor = '#' + nameColor.toString(16).padStart(6, '0');
                    div.innerHTML = `<span class="username" style="color:${hexColor};">${msg.username || 'System'}:</span> ${escapeHtml(msg.message)}`;
                    chatDisplayDiv.appendChild(div);
                });
                chatDisplayDiv.scrollTop = chatDisplayDiv.scrollHeight;
            } else {
                chatDisplayDiv.classList.add('hidden');
            }
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function updateMatchInfo() {
            if (!matchInfo) {
                matchInfoDiv.classList.add('hidden');
                return;
            }
            matchInfoDiv.classList.remove('hidden');
            let content = '';
            const gameModeName = {
                [GP.GameModeType.FreeForAll]: "FFA",
                [GP.GameModeType.TeamDeathmatch]: "TDM",
                [GP.GameModeType.CaptureTheFlag]: "CTF"
            }[matchInfo.game_mode] || "Unknown Mode";

            content += `<div class="font-semibold">${gameModeName}</div>`;

            switch (matchInfo.match_state) {
                case GP.MatchStateType.Waiting:
                    content += `<div class="text-yellow-400">Waiting for players... (${players.size}/${MIN_PLAYERS_TO_START})</div>`;
                    break;
                case GP.MatchStateType.Active:
                    const minutes = Math.floor(matchInfo.time_remaining / 60);
                    const seconds = Math.floor(matchInfo.time_remaining % 60);
                    content += `<div class="text-white">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>`;
                    if (matchInfo.game_mode === GP.GameModeType.TeamDeathmatch) {
                        content += '<div class="team-scores">';
                        let redScore = 0;
                        let blueScore = 0;
                        if (matchInfo.team_scores) {
                            matchInfo.team_scores.forEach(ts => {
                                if (ts.team_id === 1) redScore = ts.score;
                                if (ts.team_id === 2) blueScore = ts.score;
                            });
                        }
                        content += `<span class="team-score team-red">Red: ${redScore}</span>`;
                        content += `<span class="team-score team-blue">Blue: ${blueScore}</span>`;
                        content += '</div>';
                    }
                    break;
                case GP.MatchStateType.Ended:
                    content += `<div class="text-green-400">Winner: ${matchInfo.winner_name || 'Draw'}</div>`;
                    break;
            }
            matchInfoDiv.innerHTML = content;
        }

        function updateGameStatsUI() {
            if (myPlayerId && localPlayerState) {
                myPlayerIdSpan.textContent = myPlayerId.substring(0, 8);
                playerTeamSpan.textContent = localPlayerState.team_id === 1 ? 'Red' :
                    localPlayerState.team_id === 2 ? 'Blue' : 'FFA';
                playerTeamSpan.className = localPlayerState.team_id === 1 ? 'team-red' :
                    localPlayerState.team_id === 2 ? 'team-blue' : 'team-ffa';
                playerHealthSpan.textContent = localPlayerState.health;
                playerShieldSpan.textContent = localPlayerState.shield_current || 0;
                playerAmmoSpan.textContent = localPlayerState.ammo;

                if (localPlayerState.reload_progress > 0 && localPlayerState.reload_progress < 1) {
                    reloadPromptSpan.textContent = ` (Reloading ${Math.round(localPlayerState.reload_progress * 100)}%)`;
                } else {
                    reloadPromptSpan.textContent = '';
                }

                playerWeaponSpan.textContent = weaponNames[localPlayerState.weapon] || 'Unknown';
                playerScoreSpan.textContent = localPlayerState.score;
                playerKillsSpan.textContent = localPlayerState.kills;
                playerDeathsSpan.textContent = localPlayerState.deaths;

                powerupStatusDiv.innerHTML = '';
                if (localPlayerState.speed_boost_remaining > 0) {
                    powerupStatusDiv.innerHTML += `<div class="powerup-indicator"><span class="icon">ðŸƒ</span> Speed: ${Math.ceil(localPlayerState.speed_boost_remaining)}s</div>`;
                }
                if (localPlayerState.damage_boost_remaining > 0) {
                    powerupStatusDiv.innerHTML += `<div class="powerup-indicator"><span class="icon">ðŸ’ª</span> Damage: ${Math.ceil(localPlayerState.damage_boost_remaining)}s</div>`;
                }
            }
            playerCountSpan.textContent = players.size;
            pingDisplay.textContent = Math.round(ping);
        }

        // Scoreboard functions
        function toggleScoreboard(forceShow = null) {
            if (forceShow === true) {
                scoreboardDiv.classList.remove('hidden');
            } else if (forceShow === false) {
                scoreboardDiv.classList.add('hidden');
            } else {
                scoreboardDiv.classList.toggle('hidden');
            }
        }

        window.toggleScoreboard = toggleScoreboard;

        // Settings functions
        function toggleSettings() {
            settingsMenuDiv.classList.toggle('hidden');
        }

        function saveAndApplySettings() {
            gameSettings.soundEnabled = document.getElementById('soundEnabled').checked;
            gameSettings.soundVolume = document.getElementById('soundVolume').value / 100;
            gameSettings.musicEnabled = document.getElementById('musicEnabled').checked;
            gameSettings.musicVolume = document.getElementById('musicVolume').value / 100;
            gameSettings.graphicsQuality = document.getElementById('graphicsQuality').value;
            gameSettings.particleEffects = document.getElementById('particleEffects').checked;
            gameSettings.screenShake = document.getElementById('screenShake').checked;
            gameSettings.showFPS = document.getElementById('showFPS').checked;
            gameSettings.sensitivity = parseFloat(document.getElementById('sensitivity').value);

            fpsCounterDiv.classList.toggle('hidden', !gameSettings.showFPS);

            localStorage.setItem('gameSettings', JSON.stringify(gameSettings));
            log('Settings saved.', 'success');
            settingsMenuDiv.classList.add('hidden');
        }

        function loadSettings() {
            const storedSettings = localStorage.getItem('gameSettings');
            if (storedSettings) {
                gameSettings = { ...gameSettings, ...JSON.parse(storedSettings) };
                log('Settings loaded from localStorage.', 'info');
            }
            // Apply loaded settings
            document.getElementById('soundEnabled').checked = gameSettings.soundEnabled;
            document.getElementById('soundVolume').value = gameSettings.soundVolume * 100;
            document.getElementById('soundVolumeValue').textContent = Math.round(gameSettings.soundVolume * 100);
            document.getElementById('musicEnabled').checked = gameSettings.musicEnabled;
            document.getElementById('musicVolume').value = gameSettings.musicVolume * 100;
            document.getElementById('musicVolumeValue').textContent = Math.round(gameSettings.musicVolume * 100);
            document.getElementById('graphicsQuality').value = gameSettings.graphicsQuality;
            document.getElementById('particleEffects').checked = gameSettings.particleEffects;
            document.getElementById('screenShake').checked = gameSettings.screenShake;
            document.getElementById('showFPS').checked = gameSettings.showFPS;
            document.getElementById('sensitivity').value = gameSettings.sensitivity;
            document.getElementById('sensitivityValue').textContent = gameSettings.sensitivity.toFixed(1);

            fpsCounterDiv.classList.toggle('hidden', !gameSettings.showFPS);
        }

        // Settings event listeners
        settingsButton.addEventListener('click', toggleSettings);
        saveSettingsButton.addEventListener('click', saveAndApplySettings);
        cancelSettingsButton.addEventListener('click', () => {
            loadSettings();
            settingsMenuDiv.classList.add('hidden');
        });
        document.getElementById('soundVolume').addEventListener('input', (e) => {
            document.getElementById('soundVolumeValue').textContent = e.target.value;
        });
        document.getElementById('musicVolume').addEventListener('input', (e) => {
            document.getElementById('musicVolumeValue').textContent = e.target.value;
        });
        document.getElementById('sensitivity').addEventListener('input', (e) => {
            document.getElementById('sensitivityValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        document.getElementById('showFPS').addEventListener('change', (e) => {
            fpsCounterDiv.classList.toggle('hidden', !e.target.checked);
        });

        // WebRTC Connection
        connectButton.addEventListener('click', () => {
            const url = wsUrlInput.value;
            log(`Connecting to signaling server: ${url}`);
            signalingSocket = new WebSocket(url);

            signalingSocket.onopen = () => {
                log('Connected to signaling server.', 'success');
                connectButton.disabled = true;
                connectButton.textContent = 'Connected';
                connectButton.classList.add('btn-primary:disabled');
                initializePeerConnection();
                createOffer();
            };

            signalingSocket.onmessage = async (event) => {
                const msg = JSON.parse(event.data);
                if (msg.sdp) {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                        if (msg.sdp.type === 'offer') {
                            log('Server sent offer, creating answer...', 'info');
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            signalingSocket.send(JSON.stringify({ 'sdp': peerConnection.localDescription }));
                        }
                    } catch (e) {
                        log(`Error setting remote desc: ${e}`, 'error');
                    }
                } else if (msg.ice) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(msg.ice));
                    } catch (e) {
                        // Benign errors often happen with ICE candidates
                    }
                }
            };

            signalingSocket.onerror = (e) => {
                log(`Signaling error: ${e}`, 'error');
                resetConnectionUI();
            };

            signalingSocket.onclose = () => {
                log('Disconnected from signaling server.');
                resetConnectionUI();
            };
        });

        function resetConnectionUI() {
            connectButton.disabled = false;
            connectButton.textContent = 'Connect';
            connectButton.classList.remove('btn-primary:disabled');
            controlsDiv.classList.add('hidden');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Clear game state
            myPlayerId = null;
            localPlayerState = null;
            players.clear();
            projectiles.clear();
            pickups.clear();
            walls.clear();
            flagStates.clear();
            killFeed = [];
            chatMessages = [];
            matchInfo = null;
            pendingInputs = [];
            serverUpdates = [];
            inputSequence = 0;

            // Clear PIXI containers
            if (playerContainer) playerContainer.removeChildren();
            if (projectileContainer) projectileContainer.removeChildren();
            if (pickupContainer) pickupContainer.removeChildren();
            if (flagContainer) flagContainer.removeChildren();
            if (wallGraphics) wallGraphics.clear();

            log('Connection reset, game state cleared.', 'info');
        }

        function initializePeerConnection() {
            log('Initializing RTCPeerConnection...');
            peerConnection = new RTCPeerConnection(peerConnectionConfig);

            peerConnection.onicecandidate = e => {
                if (e.candidate) {
                    signalingSocket.send(JSON.stringify({ 'ice': e.candidate }));
                }
            };

            dataChannel = peerConnection.createDataChannel('gameDataChannel', {
                ordered: false,
                maxRetransmits: 0
            });

            log('DataChannel "gameDataChannel" created by client.', 'info');
            setupDataChannelEvents(dataChannel);

            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE state: ${peerConnection.iceConnectionState}`);
                if (['failed', 'disconnected', 'closed'].includes(peerConnection.iceConnectionState)) {
                    log('WebRTC disconnected.', 'error');
                    resetConnectionUI();
                }
            };

            peerConnection.ondatachannel = (event) => {
                log(`DataChannel "${event.channel.label}" received from server.`, 'info');
                dataChannel = event.channel;
                setupDataChannelEvents(dataChannel);
            };
        }

        async function createOffer() {
            try {
                log('Creating offer...');
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                signalingSocket.send(JSON.stringify({ 'sdp': peerConnection.localDescription }));
            } catch (e) {
                log(`Error creating offer: ${e}`, 'error');
            }
        }

        function setupDataChannelEvents(dcInstance) {
            dcInstance.onopen = () => {
                log(`DataChannel "${dcInstance.label}" OPENED.`, 'success');
                controlsDiv.classList.remove('hidden');
                setupInputHandlers();
                pingStartTime = Date.now();
            };

            dcInstance.onclose = () => {
                log(`DataChannel "${dcInstance.label}" CLOSED.`, 'error');
                resetConnectionUI();
            };

            dcInstance.onmessage = (event) => {
                try {
                    if (pingStartTime > 10) {
                        ping = Date.now() - pingStartTime;
                        pingStartTime = Date.now();
                    }

                    if (event.data instanceof ArrayBuffer) {
                        const parsed = parseFlatBufferMessage(event.data);

                        if (parsed) {
                            switch (parsed.type) {
                                case 'welcome':
                                    myPlayerId = parsed.playerId;
                                    log(`Welcome! Your ID: ${myPlayerId}. Server Tick: ${parsed.serverTickRate}Hz`, 'success');
                                    break;
                                case 'initial':
                                    processServerUpdate(parsed.data, true);
                                    log(`Initial game state received. Map: ${parsed.data.map_name}`, 'info');
                                    break;
                                case 'delta':
                                    processServerUpdate(parsed.data, false);
                                    break;
                                case 'chat':
                                    if (parsed.data) {
                                        chatMessages.push({
                                            seq: parsed.data.seq,
                                            player_id: parsed.data.player_id,
                                            username: parsed.data.username,
                                            message: parsed.data.message,
                                            timestamp: parsed.data.timestamp
                                        });
                                        if (chatMessages.length > 50) chatMessages.shift();
                                        updateChatDisplay();
                                    }
                                    break;
                            }
                        }
                    } else {
                        log('Received non-binary message on DataChannel.', 'error');
                    }
                } catch (e) {
                    console.error("DC Message Error:", e);
                    log(`Error processing DC message: ${e}`, 'error');
                }
            };

            dcInstance.onerror = (e) => {
                log(`DataChannel "${dcInstance.label}" error: ${JSON.stringify(e)}`, 'error');
            };
        }

        // Chat functionality
        sendChatButton.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendChatMessage();
        });

        function sendChatMessage() {
            if (dataChannel && dataChannel.readyState === 'open') {
                const text = chatInput.value.trim();
                if (text && text.length <= MAX_CHAT_MESSAGE_LENGTH) {
                    const bytes = createChatMessage(text);
                    dataChannel.send(bytes);
                    chatInput.value = '';
                } else if (text.length > MAX_CHAT_MESSAGE_LENGTH) {
                    log(`Chat message too long (max ${MAX_CHAT_MESSAGE_LENGTH} chars).`, 'error');
                }
            } else {
                log('DataChannel not open for chat.', 'error');
            }
        }

        // Initialize everything when page loads
        window.addEventListener('load', () => {
            if (typeof GameProtocol === 'undefined' || typeof GP === 'undefined') {
                log('Error: GameProtocol not loaded! Make sure to generate and include game.js', 'error');
                console.error("GameProtocol or GP is undefined. Check FlatBuffers generation and import.");
                return;
            }

            loadSettings();
            initPixi();

            log('Fullscreen optimized client initialized!', 'info');
            log('Features: Fullscreen gameplay, transparent sidebar, fixed bullet animations', 'info');
        });
    </script>
</body>

</html>
